#nullable enable
using System.Collections.Generic;
using System.Threading.Tasks;
using mud.Network.IStore;

namespace mud.Network.schemas
{
    using Property = Dictionary<string, object>;
    public static partial class DecodeStore
    {
        public static readonly TableId SchemaTableId = new("mudstore", "schema");
        public static readonly TableId MetadataTableId = new("mudstore", "StoreMetadata");

        public static async Task<Property> DecodeStoreSetRecord(IStoreService store, TableId table,
            List<string> keyTuple,
            string data)
        {
            if (table.ToHexString() == SchemaTableId.ToHexString())
            {
                var tableForSchema = keyTuple[0];
                var otherKeys = keyTuple.GetRange(1, keyTuple.Count - 1);
                if (otherKeys.Count > 0)
                {
                    Logger.Warn(
                        "registerSchema Event has more than one value in the key tuple, but this method only supports a single key");
                    await Schema.RegisterSchema(store, TableId.FromHexString(tableForSchema), data);
                }
            }

            var schema = await Schema.RegisterSchema(store, table);
            var decoded = DataDecoder.DecodeData(schema, data);

            if (table.ToHexString() == MetadataTableId.ToHexString())
            {
                var tableForMetadata = keyTuple[0];
                var otherKeys = keyTuple.GetRange(1, keyTuple.Count - 1);
                if (otherKeys.Count > 0)
                {
                    Logger.Warn(
                        $"setMetadata event has more than one value in key tuple, but this method only supports a single key, {table}");
                }

                var tableName = (string)decoded[0];
                var fieldNames = Metadata.DecodeGetRecordResult((string)decoded[1]);
                await Metadata.RegisterMetadata(store, TableId.FromHexString(tableForMetadata),
                    new TableMetadata
                    {
                        TableName = tableName,
                        FieldNames = fieldNames
                    });
            }

            var metadata = await Metadata.RegisterMetadata(store, table);
            if (metadata != null)
            {
                var namedValues = new Dictionary<string, object>();
                for (var i = 0; i < metadata.FieldNames.Count; i++)
                {
                    decoded.TryGetValue(i, out var decodedVal);
                    if (decodedVal != null)
                    {
                        namedValues[metadata.FieldNames[i]] = decodedVal;
                    }
                }

                return namedValues;
            }

            Logger.Warn(
                $"Received data for {table}, but could not find table metadata for field names. Did your contracts get autogenerated and deployed properly?"
            );

            var stringDecoded = new Dictionary<string, object>();
            for (var i = 0; i < decoded.Count-1; i++)
            {
                stringDecoded[i.ToString()] = decoded[i];
            }

            return stringDecoded;
        }
    }
}
